stack-LIFO
queue-FIFO
heap-동적메모리(개발자가 관리할 수 있음)

자바는 가비지컬랙터가 있음(GC) - 필요없는 메모리 알아서 해제 -> NEW
바이트코드의 확장자는 .class

jvm 메모리 구조를 크롬에서 검색해서 블로그를 한번 읽어보자
http://huelet.tistory.com/entry/JVM-%EB%A9%94%EB%AA%A8%EB%A6%AC%EA%B5%AC%EC%A1%B0

140p 
배열

값을 저장하는것은 변수 - 1개 저장

동일한 데이터 타입만 한번에 여러개 저장할 수 있다.
int[] a; -이게 선언하는 것
메모리 할당을 앞쪽에 저장한함
new가 필요한데 heap에 저장

c에서 구조체가 발전한것이 자바의 class라고 보면 된다.
index 첨자

배열은 처음 선언 할때 크기를 할당받는데 크기를 바꿀 수 없음
그래서 요즘은 collection 을 사용 함 - 크기를 자율적으로 바꿀수 있다.

메소드 호출에 관련된건 스택에의해서 관리된다.


	#에러가 몇십줄이나면 에러메세지의 내 파일명을 클릭해보면 에러가 난 곳을 알려준다.

146p
객체 지향 프로그래밍

메서드 만들어 놓고 호출을 해야 일을 한다.

값을 반환해 오겠다면 return있어야하고 반환타입이 void면 return이 필요 없다.


class틀을 만들고 메모리 할당을 해야하기 위해서는 실행을 해야하기 때문에 선언을 해야한다

	#.은 소속을 알려주는 연산자


생성자(151p)
Source 메뉴에서 constructor(생성자)를 만들수 있다.
생성자는 메소드이다.
생성자와 그냥 메소드의 차이
 -클래스와 이름이 똑같아야한다
 -객체를 생성할 때 자동호출이 됨 - 컨스트럭터
 -반환이란 개념이 없다.
생성자 만드는 목적은 초기화다
 - 내 클래스의 필드값을 초기화
생성자는 overloading만 가능하다 override는 불가능
생성자가 하나라도 있으면 기본생성자는 만들어지지 않는다.

overloading은 같은 클래스내에서 이름이 똑같은 것
 -매게변수 차이를 둔다.
  - 갯수, 순서, 데이터타입의 차이가 있어야 함
 -중복정의

override
 - 상속관계일 때 이름이 똑같은것
 - 부모와 완전히 똑같아야 함(예외는 있음)


퍼블릭 클래스는 하나만 존재

static
 - 클래스당 하나
 - new를 안하고도 사용할 수 있음
 - 메소드(클래스)영역에 만들어짐
 - 메소드앞에도 붙일 수 있음
 - class load할 때 클래스에 만들어짐
 - 필드랑 메소드앞에만 붙일 수 있음
 - 메소드만 있는 클래스에서 사용 할 수 있음